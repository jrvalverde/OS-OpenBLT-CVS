head	1.1;
branch	1.1.1;
access;
symbols
	openblt20000517:1.1.1.3
	openblt20000429:1.1.1.3
	openblt20000428:1.1.1.3
	openblt20000427:1.1.1.3
	openblt20000426:1.1.1.3
	openblt20000425:1.1.1.3
	openblt20000424:1.1.1.3
	openblt20000423:1.1.1.3
	openblt20000422:1.1.1.3
	openblt20000421:1.1.1.3
	openblt20000420:1.1.1.3
	openblt20000419:1.1.1.3
	openblt20000418:1.1.1.3
	openblt20000417:1.1.1.3
	openblt20000416:1.1.1.3
	openblt20000415:1.1.1.3
	openblt20000414:1.1.1.3
	openblt20000413:1.1.1.3
	openblt20000412:1.1.1.3
	openblt20000411:1.1.1.3
	openblt20000410:1.1.1.3
	openblt20000409:1.1.1.3
	openblt20000408:1.1.1.3
	openblt20000407:1.1.1.3
	openblt20000406:1.1.1.3
	openblt20000405:1.1.1.3
	openblt20000404:1.1.1.3
	openblt20000403:1.1.1.3
	openblt20000402:1.1.1.3
	openblt20000401:1.1.1.3
	openblt20000331:1.1.1.3
	openblt20000330:1.1.1.3
	openblt20000329:1.1.1.3
	openblt20000328:1.1.1.3
	openblt20000327:1.1.1.3
	openblt20000326:1.1.1.3
	openblt20000325:1.1.1.3
	openblt20000324:1.1.1.3
	openblt20000323:1.1.1.3
	openblt20000322:1.1.1.3
	openblt20000321:1.1.1.3
	openblt20000320:1.1.1.3
	openblt20000319:1.1.1.3
	openblt20000318:1.1.1.3
	openblt20000317:1.1.1.3
	openblt20000316:1.1.1.3
	openblt20000315:1.1.1.3
	openblt20000314:1.1.1.3
	openblt20000313:1.1.1.3
	openblt20000312:1.1.1.3
	openblt20000311:1.1.1.3
	openblt20000310:1.1.1.3
	openblt20000309:1.1.1.3
	openblt20000308:1.1.1.3
	openblt20000307:1.1.1.3
	openblt20000306:1.1.1.3
	openblt20000305:1.1.1.3
	openblt20000304:1.1.1.3
	openblt20000303:1.1.1.3
	openblt20000302:1.1.1.3
	openblt20000301:1.1.1.3
	openblt20000229:1.1.1.3
	openblt20000228:1.1.1.3
	openblt20000227:1.1.1.3
	openblt20000226:1.1.1.3
	openblt20000225:1.1.1.3
	openblt20000224:1.1.1.3
	openblt20000223:1.1.1.3
	openblt20000222:1.1.1.3
	openblt20000221:1.1.1.3
	openblt20000220:1.1.1.3
	openblt20000219:1.1.1.3
	openblt20000218:1.1.1.3
	openblt20000217:1.1.1.3
	openblt20000216:1.1.1.3
	openblt20000215:1.1.1.3
	openblt20000214:1.1.1.3
	openblt20000213:1.1.1.3
	openblt20000212:1.1.1.3
	openblt20000211:1.1.1.3
	openblt20000210:1.1.1.3
	openblt20000209:1.1.1.3
	openblt20000208:1.1.1.3
	openblt20000207:1.1.1.3
	openblt20000206:1.1.1.3
	openblt20000205:1.1.1.3
	openblt20000204:1.1.1.3
	openblt20000203:1.1.1.3
	openblt20000202:1.1.1.3
	openblt20000201:1.1.1.3
	openblt20000131:1.1.1.3
	openblt20000130:1.1.1.3
	openblt20000129:1.1.1.3
	openblt20000128:1.1.1.3
	openblt20000127:1.1.1.3
	openblt20000126:1.1.1.3
	openblt20000125:1.1.1.3
	openblt20000124:1.1.1.3
	openblt20000123:1.1.1.3
	openblt20000122:1.1.1.3
	openblt20000121:1.1.1.3
	openblt20000120:1.1.1.3
	openblt20000119:1.1.1.3
	openblt20000118:1.1.1.3
	openblt20000117:1.1.1.3
	openblt20000116:1.1.1.3
	openblt20000115:1.1.1.3
	openblt20000114:1.1.1.3
	openblt20000113:1.1.1.3
	openblt20000112:1.1.1.3
	openblt20000111:1.1.1.3
	openblt20000110:1.1.1.3
	openblt20000109:1.1.1.3
	openblt20000108:1.1.1.3
	openblt20000107:1.1.1.3
	openblt20000106:1.1.1.3
	openblt20000105:1.1.1.3
	openblt20000104:1.1.1.3
	openblt20000103:1.1.1.3
	openblt20000102:1.1.1.3
	openblt19991228:1.1.1.3
	openblt19990827:1.1.1.2
	openblt082699:1.1.1.2
	openblt082599:1.1.1.2
	openblt082499:1.1.1.2
	openblt082399:1.1.1.2
	openblt082299:1.1.1.2
	openblt082199:1.1.1.2
	openblt082099:1.1.1.2
	openblt081999:1.1.1.2
	openblt081899:1.1.1.2
	openblt081799:1.1.1.2
	openblt081699:1.1.1.2
	openblt081599:1.1.1.2
	openblt071199:1.1.1.2
	openblt071099:1.1.1.2
	openblt070799:1.1.1.2
	openblt070699:1.1.1.1
	openblt070299:1.1.1.1
	openblt070199:1.1.1.1
	openblt063099:1.1.1.1
	openblt062999:1.1.1.1
	start:1.1.1.1
	openBLT:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.01.20.16.23.00;	author jr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.20.16.23.00;	author jr;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.01.20.16.29.14;	author jr;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.20.16.31.53;	author jr;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $Id: //depot/blt/srv/vfs/bootfs.c#5 $
**
** Copyright 1999 Sidney Cammeresi.
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
** 1. Redistributions of source code must retain the above copyright
**	notice, this list of conditions, and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**	notice, this list of conditions, and the following disclaimer in the
**	documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**	derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <sys/stat.h>
#include <blt/syscall.h>
#include "vfs-int.h"
#include "bootfs.h"

static int inode_max = 0;

static struct vnode_ops bootfs_vnode_ops =
{
	bootfs_read_vnode, bootfs_drop_vnode, NULL, NULL, bootfs_walk, NULL,
	bootfs_mount, bootfs_unmount, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	bootfs_opendir, bootfs_closedir, NULL, bootfs_rewinddir, bootfs_readdir,
	bootfs_open, NULL, NULL, bootfs_read, NULL, NULL, NULL, bootfs_rstat,
		NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL
};

struct fs_type bootfs = { "bootfs", &bootfs_vnode_ops, NULL };

static struct bootfs_inode *bootfs_inew (const char *name, int offset,
	int size)
{
	struct bootfs_inode *inode;

	inode = malloc (sizeof (struct bootfs_inode));
	inode->i_ino = inode_max++;
	inode->i_offset = offset;
	inode->i_size = size;
	strlcpy (inode->i_name, name, sizeof (inode->i_name));
	inode->i_next = NULL;
	return inode;
}

int bootfs_mount (struct superblock *super, const char *data, int silent)
{
	int i;
	struct bootfs_sb_data *sb_data;
	struct bootfs_inode *inode;
	boot_entry *be;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_mount\n");
#endif
	sb_data = (struct bootfs_sb_data *) malloc (sizeof (struct bootfs_sb_data));
	sb_data->d_bootdir_area = area_clone (2, 0, (void **) &sb_data->d_bootdir,
		0);
	sb_data->inode_list = NULL;

	/* create inode list */
	sb_data->inode_list = bootfs_inew (".", 0, 0);
	sb_data->inode_list->i_next = bootfs_inew ("..", 0, 0);
	for (i = 0; i < BOOTDIR_MAX_ENTRIES; i++)
		if ((sb_data->d_bootdir->bd_entry[i].be_type != BE_TYPE_NONE) &&
			strcmp (sb_data->d_bootdir->bd_entry[i].be_name,
			BOOTDIR_DIRECTORY))
		{
			be = &sb_data->d_bootdir->bd_entry[i];
			inode = bootfs_inew (be->be_name, be->be_offset, be->be_vsize);
			inode->i_next = sb_data->inode_list;
			sb_data->inode_list = inode;
		}

	super->sb_data = sb_data;
	super->sb_root = vget (super, 0);
	return 0;
}

void bootfs_unmount (struct superblock *sb)
{
#ifdef BOOTFS_DEBUG
	printf ("bootfs_unmount\n");
#endif
}

int bootfs_read_vnode (struct vnode *vnode)
{
	struct bootfs_sb_data *sb_data;
	struct bootfs_inode *inode;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_read_vnode %llx\n", vnode->v_vnid);
#endif
	sb_data = vnode->v_sb->sb_data;
	inode = sb_data->inode_list;
	while (inode != NULL)
		if (inode->i_ino == vnode->v_vnid)
		{
			vnode->v_data = inode;
			return 0;
		}
		else
			inode = inode->i_next;
		
	return 0;
}

void bootfs_drop_vnode (struct vnode *vnode)
{
#ifdef BOOTFS_DEBUG
	vnode->v_data = NULL;
#endif
}

struct vnode *bootfs_walk (struct vnode *parent, const char *path)
{
	struct bootfs_sb_data *data;
	struct bootfs_inode *inode;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_walk %s\n", path);
#endif
	if (parent->v_vnid)
		return NULL;
	else
	{
		data = parent->v_sb->sb_data;
		inode = data->inode_list;
		while (inode != NULL)
			//if (!strncmp (inode->i_name, path, BOOTDIR_NAMELEN))
			if (!strcmp (inode->i_name, path))
				return vget (parent->v_sb, inode->i_ino);
			else
				inode = inode->i_next;
		return NULL;
	}
}

int bootfs_opendir (struct vnode *dir, void **cookie)
{
	struct bootfs_sb_data *data;
	struct vfs_dirent_node *head, *p;
	struct bootfs_inode *inode;
	union bootfs_cookie *bc;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_opendir\n");
#endif
	if (dir->v_vnid)
		return ENOTDIR; /* paranoia */

	head = NULL;
	data = dir->v_sb->sb_data;
	inode = data->inode_list;
	while (inode != NULL)
	{
		p = malloc (sizeof (struct vfs_dirent_node));
		p->dirent = malloc (sizeof (struct dirent));
		p->dirent->d_fileno = inode->i_ino;
		p->dirent->d_reclen = sizeof (struct dirent);
		strncpy (p->dirent->d_name, inode->i_name, sizeof (p->dirent->d_name));

		p->next = head;
		head = p;
		inode = inode->i_next;
	}

	bc = malloc (sizeof (union bootfs_cookie));
	bc->u_dir.head = bc->u_dir.current = head;
	*cookie = bc;
	return 0;
}

void bootfs_closedir (struct vnode *dir, void *cookie)
{
#ifdef BOOTFS_DEBUG
	printf ("bootfs_closedir\n");
#endif
}

int bootfs_rewinddir (struct vnode *dir, void *cookie)
{
	union bootfs_cookie *bc;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_rewinddir\n");
#endif

	bc = cookie;
	bc->u_dir.current = bc->u_dir.head;
	return 0;
}

int bootfs_readdir (struct vnode *dir, struct dirent *dirent, void *cookie)
{
	struct dirent *orig;
	union bootfs_cookie *bc;

	bc = cookie;
	if (bc->u_dir.current == NULL)
	    return 1;
	orig = bc->u_dir.current->dirent;
	dirent->d_fileno = orig->d_fileno;
	dirent->d_reclen = orig->d_reclen;
	strncpy (dirent->d_name, orig->d_name, BLT_MAX_NAME_LENGTH);
	bc->u_dir.current = bc->u_dir.current->next;
#ifdef BOOTFS_DEBUG
	printf ("bootfs_readdir %s\n", dirent->d_name);
#endif
	return 0;
}

int bootfs_open (struct vnode *vnode, void **cookie)
{
	struct bootfs_sb_data *data;
	struct bootfs_inode *inode;
	union bootfs_cookie *bc;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_open %llx\n", vnode->v_vnid);
#endif
	data = vnode->v_sb->sb_data;
	inode = vnode->v_data;
	bc = malloc (sizeof (union bootfs_cookie));
	bc->u_file.begin = (char *) data->d_bootdir + inode->i_offset * 0x1000;
	bc->u_file.pos = 0;
	*cookie = bc;
	return 0;
}

int bootfs_read (struct vnode *vnode, char *buf, size_t count, void *cookie)
{
	char *src;
	int numbytes;
	struct bootfs_sb_data *data;
	struct bootfs_inode *inode;
	union bootfs_cookie *bc;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_read %llx\n", vnode->v_vnid);
#endif
	data = vnode->v_sb->sb_data;
	inode = vnode->v_data;
	bc = cookie;
	if (bc->u_file.pos >= inode->i_size)
		return 0;
	src = (char *) data->d_bootdir + inode->i_offset * 0x1000 + bc->u_file.pos;
	numbytes = (count <= inode->i_size - bc->u_file.pos) ? count :
		(inode->i_size - bc->u_file.pos);
	memcpy (buf, src, numbytes);
	bc->u_file.pos += numbytes;
	return numbytes;
}

int bootfs_rstat (struct vnode *vnode, struct stat *buf)
{
	struct bootfs_inode *inode;

#ifdef BOOTFS_DEBUG
	printf ("bootfs_rstat %llx\n", vnode->v_vnid);
#endif
	inode = vnode->v_data;

	buf->st_ino = inode->i_ino;
	buf->st_nlink = 0;
	buf->st_uid = 0;
	buf->st_gid = 0;
	buf->st_blksize = 512;
	buf->st_size = inode->i_size;
	buf->st_blocks = (inode->i_size & 0xfff) ? (inode->i_size >> 12) + 1 :
		inode->i_size >> 12;
	return 0;
}

@


1.1.1.1
log
@openBLT source code
@
text
@@


1.1.1.2
log
@openblt.070799
@
text
@d1 1
a1 1
/* $Id: //depot/blt/srv/vfs/bootfs.c#6 $
d81 1
a81 1
	sb_data->d_bootdir_area = area_clone (3, 0, (void **) &sb_data->d_bootdir,
@


1.1.1.3
log
@openblt.19991228
@
text
@d1 1
a1 1
/* $Id: //depot/blt/srv/vfs/bootfs.c#9 $
d47 2
a48 2
	bootfs_open, bootfs_close, bootfs_free_cookie, bootfs_read, NULL,
		NULL, NULL, bootfs_rstat, NULL, NULL,
d256 1
a256 18
int bootfs_close (struct vnode *vnode, void *cookie)
{
#ifdef BOOTFS_DEBUG
	printf ("bootfs_close %llx\n", vnode->v_vnid);
#endif
	return 0;
}

void bootfs_free_cookie (void *cookie)
{
#ifdef BOOTFS_DEBUG
	printf ("bootfs_free_cookie\n");
#endif
	free (cookie);
}

int bootfs_read (struct vnode *vnode, char *buf, size_t count, off_t offset,
	size_t *numread, void *cookie)
d259 1
d270 1
a270 3
	if (offset >= inode->i_size)
	{
		*numread = 0;
d272 6
a277 6
	}
	src = (char *) data->d_bootdir + inode->i_offset * 0x1000 + offset;
	*numread = (count <= inode->i_size - offset) ? count : (inode->i_size -
		offset);
	memcpy (buf, src, *numread);
	return 0;
@


