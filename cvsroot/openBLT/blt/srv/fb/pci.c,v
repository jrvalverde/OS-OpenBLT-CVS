head	1.1;
branch	1.1.1;
access;
symbols
	openblt20000517:1.1.1.1
	openblt20000429:1.1.1.1
	openblt20000428:1.1.1.1
	openblt20000427:1.1.1.1
	openblt20000426:1.1.1.1
	openblt20000425:1.1.1.1
	openblt20000424:1.1.1.1
	openblt20000423:1.1.1.1
	openblt20000422:1.1.1.1
	openblt20000421:1.1.1.1
	openblt20000420:1.1.1.1
	openblt20000419:1.1.1.1
	openblt20000418:1.1.1.1
	openblt20000417:1.1.1.1
	openblt20000416:1.1.1.1
	openblt20000415:1.1.1.1
	openblt20000414:1.1.1.1
	openblt20000413:1.1.1.1
	openblt20000412:1.1.1.1
	openblt20000411:1.1.1.1
	openblt20000410:1.1.1.1
	openblt20000409:1.1.1.1
	openblt20000408:1.1.1.1
	openblt20000407:1.1.1.1
	openblt20000406:1.1.1.1
	openblt20000405:1.1.1.1
	openblt20000404:1.1.1.1
	openblt20000403:1.1.1.1
	openblt20000402:1.1.1.1
	openblt20000401:1.1.1.1
	openblt20000331:1.1.1.1
	openblt20000330:1.1.1.1
	openblt20000329:1.1.1.1
	openblt20000328:1.1.1.1
	openblt20000327:1.1.1.1
	openblt20000326:1.1.1.1
	openblt20000325:1.1.1.1
	openblt20000324:1.1.1.1
	openblt20000323:1.1.1.1
	openblt20000322:1.1.1.1
	openblt20000321:1.1.1.1
	openblt20000320:1.1.1.1
	openblt20000319:1.1.1.1
	openblt20000318:1.1.1.1
	openblt20000317:1.1.1.1
	openblt20000316:1.1.1.1
	openblt20000315:1.1.1.1
	openblt20000314:1.1.1.1
	openblt20000313:1.1.1.1
	openblt20000312:1.1.1.1
	openblt20000311:1.1.1.1
	openblt20000310:1.1.1.1
	openblt20000309:1.1.1.1
	openblt20000308:1.1.1.1
	openblt20000307:1.1.1.1
	openblt20000306:1.1.1.1
	openblt20000305:1.1.1.1
	openblt20000304:1.1.1.1
	openblt20000303:1.1.1.1
	openblt20000302:1.1.1.1
	openblt20000301:1.1.1.1
	openblt20000229:1.1.1.1
	openblt20000228:1.1.1.1
	openblt20000227:1.1.1.1
	openblt20000226:1.1.1.1
	openblt20000225:1.1.1.1
	openblt20000224:1.1.1.1
	openblt20000223:1.1.1.1
	openblt20000222:1.1.1.1
	openblt20000221:1.1.1.1
	openblt20000220:1.1.1.1
	openblt20000219:1.1.1.1
	openblt20000218:1.1.1.1
	openblt20000217:1.1.1.1
	openblt20000216:1.1.1.1
	openblt20000215:1.1.1.1
	openblt20000214:1.1.1.1
	openblt20000213:1.1.1.1
	openblt20000212:1.1.1.1
	openblt20000211:1.1.1.1
	openblt20000210:1.1.1.1
	openblt20000209:1.1.1.1
	openblt20000208:1.1.1.1
	openblt20000207:1.1.1.1
	openblt20000206:1.1.1.1
	openblt20000205:1.1.1.1
	openblt20000204:1.1.1.1
	openblt20000203:1.1.1.1
	openblt20000202:1.1.1.1
	openblt20000201:1.1.1.1
	openblt20000131:1.1.1.1
	openblt20000130:1.1.1.1
	openblt20000129:1.1.1.1
	openblt20000128:1.1.1.1
	openblt20000127:1.1.1.1
	openblt20000126:1.1.1.1
	openblt20000125:1.1.1.1
	openblt20000124:1.1.1.1
	openblt20000123:1.1.1.1
	openblt20000122:1.1.1.1
	openblt20000121:1.1.1.1
	openblt20000120:1.1.1.1
	openblt20000119:1.1.1.1
	openblt20000118:1.1.1.1
	openblt20000117:1.1.1.1
	openblt20000116:1.1.1.1
	openblt20000115:1.1.1.1
	openblt20000114:1.1.1.1
	openblt20000113:1.1.1.1
	openblt20000112:1.1.1.1
	openblt20000111:1.1.1.1
	openblt20000110:1.1.1.1
	openblt20000109:1.1.1.1
	openblt20000108:1.1.1.1
	openblt20000107:1.1.1.1
	openblt20000106:1.1.1.1
	openblt20000105:1.1.1.1
	openblt20000104:1.1.1.1
	openblt20000103:1.1.1.1
	openblt20000102:1.1.1.1
	openblt19991228:1.1.1.1
	openBLT:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.01.20.16.31.52;	author jr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.20.16.31.52;	author jr;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $Id$
**
** Copyright 1999 Brian J. Swetland. All rights reserved.
** Distributed under the terms of the OpenBLT License
*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

#include <i386/io.h>

#include "pci.h"

typedef struct 
{
	uchar reg:8;
	uchar func:3;
	uchar dev:5;
	uchar bus:8;
	uchar rsvd:7;
	uchar enable:1;
} confadd;

uint32 pci_read(int bus, int dev, int func, int reg, int bytes)
{
	uint32 base;
	
	union {
		confadd c;
		uint32 n;
	} u;
	
	u.c.enable = 1;
	u.c.rsvd = 0;
	u.c.bus = bus;
	u.c.dev = dev;
	u.c.func = func;
	u.c.reg = reg & 0xFC;
	
	outl(u.n,0xCF8);
	
	base = 0xCFC + (reg & 0x03);
		
	switch(bytes){
	case 1: return inb(base);
	case 2: return inw(base);
	case 4: return inl(base);
	default: return 0;
	}
}

void pci_write(int bus, int dev, int func, int reg, uint32 v, int bytes)
{
	uint32 base;
	
	union {
		confadd c;
		uint32 n;
	} u;
	
	u.c.enable = 1;
	u.c.rsvd = 0;
	u.c.bus = bus;
	u.c.dev = dev;
	u.c.func = func;
	u.c.reg = reg & 0xFC;
	
	base = 0xCFC + (reg & 0x03);
	outl(u.n,0xCF8);
	switch(bytes){
	case 1: outb(v,base); break;
	case 2: outw(v,base); break;
	case 4: outl(v,base); break;
	}
	
}

int pci_probe(int bus, int dev, int func, pci_cfg *cfg)
{
	uint32 *word = (uint32 *) cfg;
	uint32 v;	
	int i;
	for(i=0;i<4;i++){
		word[i] = pci_read(bus,dev,func,4*i,4);
	}
	if(cfg->vendor_id == 0xffff) return 1;

	cfg->bus = bus;
	cfg->dev = dev;
	cfg->func = func;
#if 0	
	printf("Device Info: /bus/pci/%d/%d/%d\n",bus,dev,func);
	printf("  * Vendor: %S   Device: %S  Class/SubClass/Interface %X/%X/%X\n",
		   cfg->vendor_id,cfg->device_id,cfg->base_class,cfg->sub_class,cfg->interface);
	printf("  * Status: %S  Command: %S  BIST/Type/Lat/CLS: %X/%X/%X/%X\n",
		   cfg->status, cfg->command, cfg->bist, cfg->header_type, 
		   cfg->latency_timer, cfg->cache_line_size);
#endif
			
	switch(cfg->header_type & 0x7F){
	case 0: /* normal device */
		for(i=0;i<6;i++){
			v = pci_read(bus,dev,func,i*4 + 0x10, 4);
			if(v) {
				int v2;
				pci_write(bus,dev,func,i*4 + 0x10, 0xffffffff, 4);
				v2 = pci_read(bus,dev,func,i*4+0x10, 4) & 0xfffffff0;
				pci_write(bus,dev,func,i*4 + 0x10, v, 4);
				v2 = 1 + ~v2;
				if(v & 1) {
//					printf("  * Base Register %d IO: %x (%x)\n",i,v&0xfff0,v2&0xffff);
					cfg->base[i] = v & 0xffff;
					cfg->size[i] = v2 & 0xffff;
				} else {
//					printf("  * Base Register %d MM: %x (%x)\n",i,v&0xfffffff0,v2);
					cfg->base[i] = v;
					cfg->size[i] = v2;
				}
			} else {
				cfg->base[i] = 0;
				cfg->size[i] = 0;
			}
			
		}
		v = pci_read(bus,dev,func,0x3c,1);
//		if((v != 0xff) && (v != 0)) printf("  * Interrupt Line: %X\n",v);
		break;
	case 1:
//		printf("  * PCI <-> PCI Bridge\n");
		break;
	default:
//		printf("  * Unknown Header Type\n");
	}
	return 0;	
}

int pci_find(pci_cfg *cfg, uint16 vendor_id, uint16 device_id)
{
	int bus,dev,func;
	
	for(bus=0;bus<255;bus++){
		for(dev=0;dev<32;dev++) {
			if(pci_probe(bus,dev,0,cfg)) continue;
			if((cfg->vendor_id == vendor_id) && 
			   (cfg->device_id == device_id)) return 0;
			if(cfg->header_type & 0x80){
				for(func=1;func<8;func++){
					if(!pci_probe(bus,dev,func,cfg) &&
					   (cfg->vendor_id == vendor_id) && 
					   (cfg->device_id == device_id)) return 0;
				}
			}
		}
	}
}

@


1.1.1.1
log
@openblt.19991228
@
text
@@
