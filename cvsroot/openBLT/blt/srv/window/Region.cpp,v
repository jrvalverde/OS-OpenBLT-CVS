head	1.1;
branch	1.1.1;
access;
symbols
	openblt20000517:1.1.1.2
	openblt20000429:1.1.1.2
	openblt20000428:1.1.1.2
	openblt20000427:1.1.1.2
	openblt20000426:1.1.1.2
	openblt20000425:1.1.1.2
	openblt20000424:1.1.1.2
	openblt20000423:1.1.1.2
	openblt20000422:1.1.1.2
	openblt20000421:1.1.1.2
	openblt20000420:1.1.1.2
	openblt20000419:1.1.1.2
	openblt20000418:1.1.1.2
	openblt20000417:1.1.1.2
	openblt20000416:1.1.1.2
	openblt20000415:1.1.1.2
	openblt20000414:1.1.1.2
	openblt20000413:1.1.1.2
	openblt20000412:1.1.1.2
	openblt20000411:1.1.1.2
	openblt20000410:1.1.1.2
	openblt20000409:1.1.1.2
	openblt20000408:1.1.1.2
	openblt20000407:1.1.1.2
	openblt20000406:1.1.1.2
	openblt20000405:1.1.1.2
	openblt20000404:1.1.1.2
	openblt20000403:1.1.1.2
	openblt20000402:1.1.1.2
	openblt20000401:1.1.1.2
	openblt20000331:1.1.1.2
	openblt20000330:1.1.1.2
	openblt20000329:1.1.1.2
	openblt20000328:1.1.1.2
	openblt20000327:1.1.1.2
	openblt20000326:1.1.1.2
	openblt20000325:1.1.1.2
	openblt20000324:1.1.1.2
	openblt20000323:1.1.1.2
	openblt20000322:1.1.1.2
	openblt20000321:1.1.1.2
	openblt20000320:1.1.1.2
	openblt20000319:1.1.1.2
	openblt20000318:1.1.1.2
	openblt20000317:1.1.1.2
	openblt20000316:1.1.1.2
	openblt20000315:1.1.1.2
	openblt20000314:1.1.1.2
	openblt20000313:1.1.1.2
	openblt20000312:1.1.1.2
	openblt20000311:1.1.1.2
	openblt20000310:1.1.1.2
	openblt20000309:1.1.1.2
	openblt20000308:1.1.1.2
	openblt20000307:1.1.1.2
	openblt20000306:1.1.1.2
	openblt20000305:1.1.1.2
	openblt20000304:1.1.1.2
	openblt20000303:1.1.1.2
	openblt20000302:1.1.1.2
	openblt20000301:1.1.1.2
	openblt20000229:1.1.1.2
	openblt20000228:1.1.1.2
	openblt20000227:1.1.1.2
	openblt20000226:1.1.1.2
	openblt20000225:1.1.1.2
	openblt20000224:1.1.1.2
	openblt20000223:1.1.1.2
	openblt20000222:1.1.1.2
	openblt20000221:1.1.1.2
	openblt20000220:1.1.1.2
	openblt20000219:1.1.1.2
	openblt20000218:1.1.1.2
	openblt20000217:1.1.1.2
	openblt20000216:1.1.1.2
	openblt20000215:1.1.1.2
	openblt20000214:1.1.1.2
	openblt20000213:1.1.1.2
	openblt20000212:1.1.1.2
	openblt20000211:1.1.1.2
	openblt20000210:1.1.1.2
	openblt20000209:1.1.1.2
	openblt20000208:1.1.1.2
	openblt20000207:1.1.1.2
	openblt20000206:1.1.1.2
	openblt20000205:1.1.1.2
	openblt20000204:1.1.1.2
	openblt20000203:1.1.1.2
	openblt20000202:1.1.1.2
	openblt20000201:1.1.1.2
	openblt20000131:1.1.1.2
	openblt20000130:1.1.1.2
	openblt20000129:1.1.1.2
	openblt20000128:1.1.1.2
	openblt20000127:1.1.1.2
	openblt20000126:1.1.1.2
	openblt20000125:1.1.1.2
	openblt20000124:1.1.1.2
	openblt20000123:1.1.1.2
	openblt20000122:1.1.1.2
	openblt20000121:1.1.1.2
	openblt20000120:1.1.1.2
	openblt20000119:1.1.1.2
	openblt20000118:1.1.1.2
	openblt20000117:1.1.1.2
	openblt20000116:1.1.1.2
	openblt20000115:1.1.1.2
	openblt20000114:1.1.1.2
	openblt20000113:1.1.1.2
	openblt20000112:1.1.1.2
	openblt20000111:1.1.1.2
	openblt20000110:1.1.1.2
	openblt20000109:1.1.1.2
	openblt20000108:1.1.1.2
	openblt20000107:1.1.1.2
	openblt20000106:1.1.1.2
	openblt20000105:1.1.1.2
	openblt20000104:1.1.1.2
	openblt20000103:1.1.1.2
	openblt20000102:1.1.1.2
	openblt19991228:1.1.1.1
	openBLT:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2005.01.20.16.31.56;	author jr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.20.16.31.56;	author jr;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.01.20.16.32.14;	author jr;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "Region.h"
#include "util.h"

const int kRectAllocSize = 16;

Region::Region()
	:	fRects(0),
		fNumRects(0),
		fOpLevel(0)
{
}

Region::Region(const Region &copyRegion)
	:	fRects(0),
		fNumRects(0),
		fOpLevel(0)
{
	SetTo(copyRegion);
}

Region::~Region()
{
	free(fRects);
}

Region& Region::SetTo(const Region &copyRegion)
{
	AllocSpace(copyRegion.fNumRects);
	fNumRects = copyRegion.fNumRects;
	memcpy(fRects, copyRegion.fRects, fNumRects * sizeof(Rect));
	return *this;
}

Region& Region::operator=(const Region &copyRegion)
{
	return SetTo(copyRegion);
}

Rect Region::Bounds() const
{
	Rect bounds(COORD_MAX, COORD_MAX, -COORD_MAX, -COORD_MAX);
	for (int i = 0; i < fNumRects; i++) {
		const Rect &rect = RectAt(i);
		bounds.left = min(bounds.left, rect.left);
		bounds.right = max(bounds.right, rect.right);
		bounds.top = min(bounds.top, rect.top);
		bounds.bottom = max(bounds.bottom, rect.bottom);
	}

	return bounds;
}

Region& Region::Include(const Rect &rect)
{
	Region temp;

	BeginOperation();
	// Make sure that there are no overlaps
	temp.AddRect(rect);
	for (int i = 0; i < fNumRects; i++)
		temp.Exclude(RectAt(i));

	AddRegionRects(temp);
	EndOperation();
	return *this;
}

Region& Region::Include(const Region &region)
{
	BeginOperation();
	for (int i = 0; i < region.CountRects(); i++)
		Include(region.RectAt(i));
	EndOperation();

	return *this;
}

#define SPLIT_TEST(rect1, rect2)											\
	(max(rect1.left, rect2.left) < min(rect1.right, rect2.right)			\
		&& max(rect1.top, rect2.top) < min(rect1.bottom, rect2.bottom))

Region& Region::Exclude(const Rect &excludeRect)
{
	BeginOperation();
	int index = 0;
	int rectsToCheck = fNumRects;
	while (index < rectsToCheck) {
		Rect &clipRect = fRects[index];

		if (!excludeRect.Intersects(clipRect)) {
			index++;
			continue;
		}

		// This clip rect intersects the excluded rect, and could be divided into
		// as many as eight pieces.  Test for each case.  Note that none of these
		// rectangles overlap!!!!
		Rect quad1(clipRect.left, clipRect.top, excludeRect.left - 1, excludeRect.top - 1);
		if (SPLIT_TEST(clipRect, quad1)) {
			quad1.Intersect(clipRect);
			AddRect(quad1);
		}

		Rect quad2(excludeRect.left, clipRect.top, excludeRect.right, excludeRect.top - 1);
		if (SPLIT_TEST(clipRect, quad2)) {
			quad2.Intersect(clipRect);
			AddRect(quad2);
		}

		Rect quad3(excludeRect.right + 1, clipRect.top, clipRect.right, excludeRect.top - 1);
		if (SPLIT_TEST(clipRect, quad3)) {
			quad3.Intersect(clipRect);
			AddRect(quad3);
		}

		Rect quad4(clipRect.left, excludeRect.top, excludeRect.left - 1, excludeRect.bottom);
		if (SPLIT_TEST(clipRect, quad4)) {
			quad4.Intersect(clipRect);
			AddRect(quad4);
		}

		Rect quad5(excludeRect.right + 1, excludeRect.top, clipRect.right, excludeRect.bottom);
		if (SPLIT_TEST(clipRect, quad5)) {
			quad5.Intersect(clipRect);
			AddRect(quad5);
		}

		Rect quad6(clipRect.left, excludeRect.bottom + 1, excludeRect.left - 1, clipRect.bottom);
		if (SPLIT_TEST(clipRect, quad6)) {
			quad6.Intersect(clipRect);
			AddRect(quad6);
		}

		Rect quad7(excludeRect.left, excludeRect.bottom + 1, excludeRect.right, clipRect.bottom);
		if (SPLIT_TEST(clipRect, quad7)) {
			quad7.Intersect(clipRect);
			AddRect(quad7);
		}

		Rect quad8(excludeRect.right + 1, excludeRect.bottom + 1, clipRect.right, clipRect.bottom);
		if (SPLIT_TEST(clipRect, quad8)) {
			quad8.Intersect(clipRect);
			AddRect(quad8);	
		}

		// This rect has been split, remove it.  Note we don't
		// change the index
		RemoveRect(index);		
		rectsToCheck--;
	}
	EndOperation();
	return *this;
}

Region& Region::Exclude(const Region &ex)
{
	BeginOperation();
	Region temp(ex);
	temp.Invert();
	Intersect(temp);
	EndOperation();
	return *this;
}



Region& Region::Clear()
{
	fNumRects = 0;
	AllocSpace(0);
	return *this;
}

Region& Region::ConstrainTo(const Rect &rect)
{
	BeginOperation();
	for (int i = fNumRects - 1; i >= 0; i--) {
		fRects[i].left = max(rect.left, fRects[i].left);
		fRects[i].right = min(rect.right, fRects[i].right);
		fRects[i].top = max(rect.top, fRects[i].top);
		fRects[i].bottom = min(rect.bottom, fRects[i].bottom);
		if (!fRects[i].Valid())
			RemoveRect(i);
	}
	
	EndOperation();
	return *this;
}

Region& Region::Translate(int x, int y)
{
	for (int i = 0; i < fNumRects; i++) {
		fRects[i].left += x;
		fRects[i].right += x;
		fRects[i].top += y;
		fRects[i].bottom += y;
	}

	return *this;
}

Region& Region::Intersect(const Region &intersectRegion)
{
	BeginOperation();
	Region newRegion;
	for (int i = 0; i < fNumRects; i++) {
		for (int j = 0; j < intersectRegion.fNumRects; j++) {
			if (RectAt(i).Intersects(intersectRegion.RectAt(j))) {
				Rect temp(RectAt(i));
				temp.Intersect(intersectRegion.RectAt(j));
				newRegion.AddRect(temp);
			}
		}
	}
	
	SetTo(newRegion);
	EndOperation();
	return *this;
}

Region& Region::Invert()
{
	BeginOperation();
	Region temp;
	temp.Include(Rect(-COORD_MAX, -COORD_MAX, COORD_MAX, COORD_MAX));
	for (int i = 0; i < fNumRects; i++)
		temp.Exclude(fRects[i]);

	SetTo(temp);
	EndOperation();
	return *this;
}

const bool Region::FindRect(int x, int y, Rect &outRect)
{
	for (int i = 0; i < CountRects(); i++) {
		if (RectAt(i).Contains(x, y)) {
			outRect = RectAt(i);
			return true;
		}
	}

	return false;
}

void Region::AddRect(const Rect &rect)
{
	AllocSpace(fNumRects + 1);
	fRects[fNumRects++] = rect;
}

void Region::RemoveRect(int index)
{
	fNumRects--;
	memcpy(fRects + index, fRects + index + 1, (fNumRects - index) * sizeof(Rect));
	AllocSpace(fNumRects);
}

void Region::AddRegionRects(const Region &region)
{
	for (int i = 0; i < region.fNumRects; i++)
		AddRect(region.RectAt(i));
}

void Region::Consolidate()
{
	// Optimize region by consolidating adjacent rectangles.
	for (int i = 0; i < fNumRects; i++) {
		for (int j = fNumRects - 1; j > i; j--) {
			Rect &rect1 = fRects[i];
			Rect &rect2 = fRects[j];
			if (rect1.top == rect2.top && rect1.bottom == rect2.bottom) {
				if (rect1.right + 1 == rect2.left) {
					rect1.right = rect2.right;
					RemoveRect(j);				
				} else if (rect2.right + 1 == rect1.left) {
					rect1.left = rect2.left;
					RemoveRect(j);
				}
			} else if (rect1.left == rect2.left && rect1.right == rect2.right) {
				if (rect1.top == rect2.bottom + 1) {
					rect1.top = rect2.top;
					RemoveRect(j);
				} else if (rect1.bottom + 1 == rect2.top) {
					rect1.bottom = rect2.bottom;
					RemoveRect(j);
				}
			}
		}
	}
}

void Region::AllocSpace(int numRects)
{
	int currentAlloc = ((fNumRects + kRectAllocSize - 1) / kRectAllocSize)
		* kRectAllocSize;
	int sizeWanted = ((numRects + kRectAllocSize - 1) / kRectAllocSize)
		* kRectAllocSize;

	if (sizeWanted != currentAlloc) {
		if (fRects == 0 && sizeWanted > 0)
			fRects = malloc(sizeWanted * sizeof(Rect));
		else if (sizeWanted == 0 && fRects != 0) {
			free(fRects);
			fRects = 0;
		} else
			fRects = realloc(fRects, sizeWanted * sizeof(Rect));
	}
}


void Region::BeginOperation()
{
	fOpLevel++;
}

void Region::EndOperation()
{
	if (--fOpLevel == 0)
		Consolidate();
		
	ASSERT(fOpLevel >= 0);
}



void Region::Dump() const
{
	printf("Region:  ");
	for (int i = 0; i < fNumRects; i++) { 
		if ((i % 6) == 5)
			printf("\n");
		printf("(%d %d %d %d)   ", fRects[i].left, fRects[i].top, fRects[i].right,
			fRects[i].bottom);
	}

	printf("\n");
}
@


1.1.1.1
log
@openblt.19991228
@
text
@@


1.1.1.2
log
@openblt.20000102
@
text
@d237 1
a237 1
const bool Region::FindRect(int x, int y, Rect &outRect) const
d305 1
a305 1
			fRects = (Rect*) malloc(sizeWanted * sizeof(Rect));
d310 1
a310 1
			fRects = (Rect*) realloc(fRects, sizeWanted * sizeof(Rect));
@

