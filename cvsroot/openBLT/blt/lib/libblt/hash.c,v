head	1.1;
branch	1.1.1;
access;
symbols
	openblt20000517:1.1.1.2
	openblt20000429:1.1.1.2
	openblt20000428:1.1.1.2
	openblt20000427:1.1.1.2
	openblt20000426:1.1.1.2
	openblt20000425:1.1.1.2
	openblt20000424:1.1.1.2
	openblt20000423:1.1.1.2
	openblt20000422:1.1.1.2
	openblt20000421:1.1.1.2
	openblt20000420:1.1.1.2
	openblt20000419:1.1.1.2
	openblt20000418:1.1.1.2
	openblt20000417:1.1.1.2
	openblt20000416:1.1.1.2
	openblt20000415:1.1.1.2
	openblt20000414:1.1.1.2
	openblt20000413:1.1.1.2
	openblt20000412:1.1.1.2
	openblt20000411:1.1.1.2
	openblt20000410:1.1.1.2
	openblt20000409:1.1.1.2
	openblt20000408:1.1.1.2
	openblt20000407:1.1.1.2
	openblt20000406:1.1.1.2
	openblt20000405:1.1.1.2
	openblt20000404:1.1.1.2
	openblt20000403:1.1.1.2
	openblt20000402:1.1.1.2
	openblt20000401:1.1.1.2
	openblt20000331:1.1.1.2
	openblt20000330:1.1.1.2
	openblt20000329:1.1.1.2
	openblt20000328:1.1.1.2
	openblt20000327:1.1.1.2
	openblt20000326:1.1.1.2
	openblt20000325:1.1.1.2
	openblt20000324:1.1.1.2
	openblt20000323:1.1.1.2
	openblt20000322:1.1.1.2
	openblt20000321:1.1.1.2
	openblt20000320:1.1.1.2
	openblt20000319:1.1.1.2
	openblt20000318:1.1.1.2
	openblt20000317:1.1.1.2
	openblt20000316:1.1.1.2
	openblt20000315:1.1.1.2
	openblt20000314:1.1.1.2
	openblt20000313:1.1.1.2
	openblt20000312:1.1.1.2
	openblt20000311:1.1.1.2
	openblt20000310:1.1.1.2
	openblt20000309:1.1.1.2
	openblt20000308:1.1.1.2
	openblt20000307:1.1.1.2
	openblt20000306:1.1.1.2
	openblt20000305:1.1.1.2
	openblt20000304:1.1.1.2
	openblt20000303:1.1.1.2
	openblt20000302:1.1.1.2
	openblt20000301:1.1.1.2
	openblt20000229:1.1.1.2
	openblt20000228:1.1.1.2
	openblt20000227:1.1.1.2
	openblt20000226:1.1.1.2
	openblt20000225:1.1.1.2
	openblt20000224:1.1.1.2
	openblt20000223:1.1.1.2
	openblt20000222:1.1.1.2
	openblt20000221:1.1.1.2
	openblt20000220:1.1.1.2
	openblt20000219:1.1.1.2
	openblt20000218:1.1.1.2
	openblt20000217:1.1.1.2
	openblt20000216:1.1.1.2
	openblt20000215:1.1.1.2
	openblt20000214:1.1.1.2
	openblt20000213:1.1.1.2
	openblt20000212:1.1.1.2
	openblt20000211:1.1.1.2
	openblt20000210:1.1.1.2
	openblt20000209:1.1.1.2
	openblt20000208:1.1.1.2
	openblt20000207:1.1.1.2
	openblt20000206:1.1.1.2
	openblt20000205:1.1.1.2
	openblt20000204:1.1.1.2
	openblt20000203:1.1.1.2
	openblt20000202:1.1.1.2
	openblt20000201:1.1.1.2
	openblt20000131:1.1.1.2
	openblt20000130:1.1.1.2
	openblt20000129:1.1.1.2
	openblt20000128:1.1.1.2
	openblt20000127:1.1.1.2
	openblt20000126:1.1.1.2
	openblt20000125:1.1.1.2
	openblt20000124:1.1.1.2
	openblt20000123:1.1.1.2
	openblt20000122:1.1.1.2
	openblt20000121:1.1.1.2
	openblt20000120:1.1.1.2
	openblt20000119:1.1.1.2
	openblt20000118:1.1.1.2
	openblt20000117:1.1.1.2
	openblt20000116:1.1.1.2
	openblt20000115:1.1.1.2
	openblt20000114:1.1.1.2
	openblt20000113:1.1.1.2
	openblt20000112:1.1.1.2
	openblt20000111:1.1.1.2
	openblt20000110:1.1.1.2
	openblt20000109:1.1.1.2
	openblt20000108:1.1.1.2
	openblt20000107:1.1.1.2
	openblt20000106:1.1.1.2
	openblt20000105:1.1.1.2
	openblt20000104:1.1.1.2
	openblt20000103:1.1.1.2
	openblt20000102:1.1.1.2
	openblt19991228:1.1.1.2
	openblt19990827:1.1.1.2
	openblt082699:1.1.1.2
	openblt082599:1.1.1.2
	openblt082499:1.1.1.2
	openblt082399:1.1.1.2
	openblt082299:1.1.1.2
	openblt082199:1.1.1.2
	openblt082099:1.1.1.2
	openblt081999:1.1.1.2
	openblt081899:1.1.1.2
	openblt081799:1.1.1.2
	openblt081699:1.1.1.2
	openblt081599:1.1.1.2
	openblt071199:1.1.1.2
	openblt071099:1.1.1.1
	openblt070799:1.1.1.1
	openblt070699:1.1.1.1
	openblt070299:1.1.1.1
	openblt070199:1.1.1.1
	openblt063099:1.1.1.1
	openblt062999:1.1.1.1
	start:1.1.1.1
	openBLT:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.01.20.16.22.59;	author jr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.20.16.22.59;	author jr;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.01.20.16.29.33;	author jr;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $Id: //depot/blt/lib/libblt/hash.c#2 $
**
** Copyright 1999 Sidney Cammeresi.
** All rights reserved.
** 
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
** 
** 1. Redistributions of source code must retain the above copyright notice,
**    this list of conditions and the following disclaimer.
** 
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
** 
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS' AND ANY EXPRESS OR IMPLIED
** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
** NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * these algorithms are based on knuth's algorithm 6.4d, as described in
 * vol. 3, p. 529 of taocp.
 *
 * XXX - keys must be unique!
 */

/*

the primes were computed by using the following program:

int main (void)
{
    unsigned int i, j, good, last;

    for (i = 17, last = 0; i < 65536 * 16384 - 1; i++)
        {   
            for (j = 2, good = 1; (j <= floor (sqrt ((double) i))) && good; j++)
                if (!(i % j))
                    good = 0;
            if (good)
                {
                    if (last == i - 2)
                        {
                            printf ("%d %d\n", last, i);
                            i *= 2;
                        }
                    last = i;
                }
        }

    return 0;
}

*/

#include <stddef.h>
#include <blt/hash.h>

static unsigned int table_size[] = { 7, 19, 43, 103, 229, 463, 1021, 2083, 4219,
	8539, 17191, 34471, 69031, 138079, 276373, 552751, 1105549, 2211259,
	4422619, 8845453, 17691043, 35382091, 70764259, 141528559, 283057213,
	566115259 };

static int hash (int key, int size);
static int rehash (int key, int size);
static void hashtable_rebuild (hashtable_t *t, int dir);

static int hash (int key, int size)
{
	return key % table_size[size];
}

static int rehash (int key, int size)
{
	return 1 + (key % (table_size[size] - 2));
}

hashtable_t *hashtable_new (float max_load)
{
	int i;
	hashtable_t *t;

	t = (hashtable_t *) malloc (sizeof (hashtable_t));
	t->size_index = 0;
	t->used = t->dirty = 0;
	t->max_load = max_load;
	t->table = (hashnode_t *) malloc (sizeof (hashnode_t) * *table_size);
	for (i = 0; i < table_size[t->size_index]; i++)
		t->table[i].valid = t->table[i].dirty = 0;
	return t;
}

void hashtable_del (hashtable_t *t)
{
	free (t->table);
}

void hashtable_insert (hashtable_t *t, int key, void *data, int dsize)
{
	int i, c;

	if (t->used > (t->max_load * table_size[t->size_index]))
		hashtable_rebuild (t, 1);

	i = hash (key, t->size_index);
	if (t->table[i].valid)
		do
			{
				c = rehash (key, t->size_index);
				i -= c;
				if (i < 0)
					i += table_size[t->size_index];
			}
		while (t->table[i].valid && !t->table[i].dirty);
	if (!t->table[i].dirty)
		t->used++;
	t->table[i].valid = 1;
	t->table[i].dirty = 0;
	t->table[i].key = key;
	t->table[i].dsize = dsize;
	t->table[i].data = data;
}

static void hashtable_rebuild (hashtable_t *t, int dir)
{
	int i, old_index;
	hashnode_t *old;

	old = t->table;
	old_index = t->size_index;
	switch (dir)
		{
			case -1:
				t->size_index = t->size_index ? t->size_index - 1 : 0;
				break;
			case 0:
				break;
			case 1:
				t->size_index++;
				break;
			default:
				return;
		}

	t->used = t->dirty = 0;
	t->table = (hashnode_t *) malloc (sizeof (hashnode_t) *
		table_size[t->size_index]);
	for (i = 0; i < table_size[t->size_index]; i++)
		t->table[i].valid = t->table[i].dirty = 0;
	for (i = 0; i < table_size[old_index]; i++)
		if (old[i].valid && !old[i].dirty)
			hashtable_insert (t, old[i].key, old[i].data, old[i].dsize);
	free (old);
}

void *hashtable_lookup (hashtable_t *t, int key, int *dsize)
{
	int i, c;

	i = hash (key, t->size_index);
	while (t->table[i].valid)
		{
			if ((t->table[i].key == key) && !t->table[i].dirty)
				{
					if (dsize != NULL)
						*dsize = t->table[i].dsize;
					return t->table[i].data;
				}
			c = rehash (key, t->size_index);
			i -= c;
			if (i < 0)
				i += table_size[t->size_index];
		}
	if (dsize != NULL)
		*dsize = 0;
	return NULL;
}

void *hashtable_remove (hashtable_t *t, int key, int *dsize)
{
	int i, c;
	void *temp;

	i = hash (key, t->size_index);
	while (t->table[i].valid)
		{
			if ((t->table[i].key == key) && !t->table[i].dirty)
				{
					if (dsize != NULL)
						*dsize = t->table[i].dsize;
					temp = t->table[i].data;
					t->table[i].dirty = 1;
					t->dirty++;
					if ((t->dirty > ((1 - t->max_load) *
							table_size[t->size_index])) && t->size_index)
						hashtable_rebuild (t, -1);
					return temp;
				}
			c = rehash (key, t->size_index);
			i -= c;
			if (i < 0)
				i += table_size[t->size_index];
		}
	if (dsize != NULL)
		*dsize = 0;
	return NULL;
}

/*
void hashtable_print (hashtable_t *t)
{
	int i;

	printf ("used:  %d\ndirty: %d\n\n", t->used, t->dirty);
	for (i = 0; i < table_size[t->size_index]; i++)
		printf ("%3d: %d %d %3d %3d %3d\n", i, t->table[i].valid,
			t->table[i].dirty, t->table[i].key,
			t->table[i].data, t->table[i].dsize);
}
*/

@


1.1.1.1
log
@openBLT source code
@
text
@@


1.1.1.2
log
@openblt.071199
@
text
@d1 1
a1 1
/* $Id: //depot/blt/lib/libblt/hash.c#3 $
a68 1
#include <stdlib.h>
@

